
/* ========================================================================== */
//#include "TM1638.h"
/* ========================================================================== */
#define __USE__TM1638__   (1)

//
// Based on http://avr.nikolaew.org/modules/tm1638
//______________________________________________________________________________
//
// Класс для платки LED-KEY на TM1638 x8 7-ми сегментных, 8 LED, 8 key
// Должны быть определены дефайнами :
// TM1638_STB, TM1638_CLK, TM1638_DI, TM1638_DO, TM1638_OUTPUT
// Например:
// #define TM1638_STB PORTA_Bit0
// #define TM1638_CLK PORTA_Bit1
// #define TM1638_DO PORTA_Bit2
// #define TM1638_DI PINA_Bit2
// #define TM1638_OUTPUT DDRA_Bit2
// И еще должна быть определена тактовая, в мегагерцах, 8 МГц = 8
// #define MHZ 8
//
// TM1638_STB и TM1638_CLK должны быть настроены на ВЫВОД
// Структура памяти у этой платы странная – байт – индикатор,
// байт (точнее мл.бит) – свектодиод над ним. Потому автоинкрементная
// запись не годится. Хотя тут не структура памяти 1638, а схема платы виновата.
//
// ____________________СИСТЕМА КОМАНД 1638______________________________________
// Address Command Set (1100.aaaa) a-dress
// Display Control Command Set (1000.PBBB) P-ower,B-right
// Data Command Set (0100.0fR0) f-ixed,R-ead
//______________________________________________________________________________
//
//Вот и всё. Вставляете это в текст или по include, не забыв предварительно
// определить пины (см. в шапке текста) и тактовую частоту МК . Потом объявляете
//    LED_KEY_TM1638 display;
//При инициализации программы вызывваете display.init() – и можно работать.
// Так, чтобы зажечь первый одиночный светодиод – вызываете display.led_on(0).
// Да, еще надо “включить” весь блок индикатора вызвав display.on(яркость)
//______________________________________________________________________________

#if (1==__USE__TM1638__)
#define MHZ 8

/*#include "./include/DSP28x_Project.h"
#include "./include/F2802x_Examples.h"
#include "./include/F2802x_GlobalPrototypes.h"
#include "./include/cpu.h"
#include "./include/clk.h"
#include "./include/flash.h"
#include "./include/gpio.h"
#include "./include/pll.h"
#include "./include/pwm.h"
#include "./include/wdog.h"
#include "./include/pie.h"
//#include "./include/pie_init.h"
#include "./include/timer.h"
#include "./include/adc.h"
#include "./include/sci.h"*/
//#include "./F28027_SCI.h"

#include "./include/DSP28x_Project.h"
#include "./include/F2802x_Examples.h"
#include "./include/F2802x_GlobalPrototypes.h"
#include "./include/gpio.h"

/* ========================================================================== */

extern GPIO_Handle  myGpio;

#define TM1638_OUTPUT(x)  ( GPIO_setDirection(myGpio,GPIO_Number_2,x==0?GPIO_Direction_Input:GPIO_Direction_Output) ) //DDRA_Bit2
#define TM1638_STB(x)     ( x==0 ? GPIO_setLow : GPIO_setHigh(myGpio, GPIO_Number_2) ) //PORTA_Bit0
#define TM1638_CLK(x)     ( x==0 ? GPIO_setLow : GPIO_setHigh(myGpio, GPIO_Number_1) ) //PORTA_Bit1
#define TM1638_DO(x)      ( x==0 ? GPIO_setLow : GPIO_setHigh(myGpio, GPIO_Number_0) ) //PORTA_Bit2
#define TM1638_DI         ( GPIO_getData (myGpio, GPIO_Number_0) ) //PINA_Bit2

/* ========================================================================== */
void tm1638_write(char B);
char tm1638_read(void);
void tm1638_init(void);
void tm1638_clear(char fill); // очистка 7-сегментных (0) ну или заполнение
void tm1638_off(void); // выключить всё
void tm1638_on(char bright); // ВКЛ. с опред. яркостью (8 градаций, 0=MIN)
void tm1638_prints(char * str); // Вывести на 7-сегм. 8 байт из буфера, невзирая на 0
void tm1638_printx(char sym,char X); // Вывести на 7-сегм. 1 байт в позицию X
void tm1638_led_on(char num); // включить-выключить 1 светодиод
void tm1638_led_off(char num);
void tm1638_leds(char mask); // вывод всех 8-ми светодиодов, мл.бит=левый
char tm1638_getkeys(void); // вернет байт состояния кнопок, мл.бит = левый
/* ========================================================================== */


/* ========================================================================== */
#pragma CODE_SECTION( tm1638_write,   "ramfunc" );
#pragma CODE_SECTION( tm1638_read,    "ramfunc" );
#pragma CODE_SECTION( tm1638_init,    "ramfunc" );
#pragma CODE_SECTION( tm1638_clear,   "ramfunc" );
#pragma CODE_SECTION( tm1638_off,     "ramfunc" );
#pragma CODE_SECTION( tm1638_on,      "ramfunc" );
#pragma CODE_SECTION( tm1638_prints,  "ramfunc" );
#pragma CODE_SECTION( tm1638_printx,  "ramfunc" );
#pragma CODE_SECTION( tm1638_led_on,  "ramfunc" );
#pragma CODE_SECTION( tm1638_led_off, "ramfunc" );
#pragma CODE_SECTION( tm1638_leds,    "ramfunc" );
#pragma CODE_SECTION( tm1638_getkeys, "ramfunc" );
/* ========================================================================== */


/* ========================================================================== */
// Вывод байта SPI
// STB должен быть установлен ДО того
/* ========================================================================== */
void tm1638_write(char B) {
	char i;

	for (i=8; i>0; i--) {
		TM1638_CLK (0);
		TM1638_DO (B & 0x01);
		TM1638_CLK (1);
		B = B >> 1;
	}
}
/* ========================================================================== */



/* ========================================================================== */
// STB должен быть установлен ДО того
/* ========================================================================== */
char tm1638_read(void) {
	char B=0, i;
	for (i=8; i > 0; i--) {
		B = B >> 1;
		TM1638_CLK (0);

		__delay_cycles(MHZ*1); // 1 uS

		if ( TM1638_DI ) B |= 0x80;

		TM1638_CLK (1);
	}
	return(B);
}
/* ========================================================================== */



/* ========================================================================== */
// очистка-заполнение
// LED не трогаем, только 7-сегментные
/* ========================================================================== */
void tm1638_clear(char fill) {
	char i;

	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*1); // 1 uS
	tm1638_write(0x42); // запись, НЕ авто++!

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	TM1638_STB (0);

	for (i=0; i < 8; i++) {
		tm1638_write(0xC0+i+i); // address
		tm1638_write(fill);
	}
	TM1638_STB (1);
	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Начальное состояние линий и очистка индикатора (но не включение! см. on() )
/* ========================================================================== */
void tm1638_init(void) {
	TM1638_OUTPUT (0);
	TM1638_STB (1);
	TM1638_CLK (1);

	__delay_cycles(MHZ*1); // 1 uS
	tm1638_clear(0x00);
}
/* ========================================================================== */



/* ========================================================================== */
// Выключить индикацию
/* ========================================================================== */
void tm1638_off(void) {
	TM1638_OUTPUT (1);
	TM1638_STB (0);

	tm1638_write(0x80); // OFF display

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Включить индикацию, 8 уровней яркости
/* ========================================================================== */
void tm1638_on(char bright) {
	TM1638_OUTPUT (1);
	TM1638_STB (0);

	tm1638_write(0x88 | (bright & 0x07));

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Вывод 8 -ми байт из буфера. Должно уже быть перекодировано в 7-сегм
// Например по таблице
// char decode0F[]={0x3F,0×06,0x5B,0x4F,0×66,0x6D, 0x7D,0×07,0x7F,0x6F,0×77,0x7C,0×39,0x5E,0×79,0×71};
/* ========================================================================== */
void tm1638_prints(char * str) {
	char i;

	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*1); // 1 uS
	tm1638_write(0x44); // запись, авто++

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	for ( i=0; i<8; i++) {
		TM1638_STB (0);

		tm1638_write(0xC0+i+i); // address
		tm1638_write(*(str)++);

		TM1638_STB (1);
	}
	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Вывод байта sym на индикатор X (без проверки границ, однао)
// Не забыть что 0 это код 0x3F
/* ========================================================================== */
void tm1638_printx(char sym, char X) {
	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*1); // 1 uS

	tm1638_write(0x44); // запись, авто++

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	TM1638_STB (0);

	tm1638_write(0xC0+X+X); // address
	tm1638_write(sym);

	TM1638_STB (1);
	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Зажечь одиночный светодиод сверху
/* ========================================================================== */
void tm1638_led_on(char num) {
	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*1); // 1 uS
	tm1638_write(0x44); // fixed write

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	TM1638_STB (0);

	tm1638_write(0xC1+num+num); // address
	tm1638_write(0x01);

	TM1638_STB (1);
	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Погасить одиночный светодиод сверху
/* ========================================================================== */
void tm1638_led_off(char num) {
	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*1); // 1 uS
	tm1638_write(0x44); // fixed write

	TM1638_STB (1);

	__delay_cycles(MHZ*1);

	TM1638_STB (0);

	tm1638_write(0xC1+num+num); // address
	tm1638_write(0x00);

	TM1638_STB (1);
	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Вывести сразу 8 одиночных индикаторов
/* ========================================================================== */
void tm1638_leds(char mask) {
	char i;

	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*1); // 1 uS
	tm1638_write(0x44); // fixed write

	TM1638_STB (1);

	__delay_cycles(MHZ*1);
	for (i=0; i<8; i++) {
		TM1638_STB (0);

		tm1638_write(0xC1+i+i); // address
		tm1638_write(mask & 0x01);

		TM1638_STB (1);

		mask>>=1;
	}
	TM1638_OUTPUT (0);
}
/* ========================================================================== */



/* ========================================================================== */
// Вернет состояние кнопок (нажато = 1)
/* ========================================================================== */
char tm1638_getkeys(void) {
	char result = 0;
	char T;

	TM1638_OUTPUT (1);
	TM1638_STB (0);

	__delay_cycles(MHZ*8);

	write(0x42); // чтение, авто++

	TM1638_OUTPUT (0);
	TM1638_DO (1); // подпорка О.К.

	__delay_cycles(MHZ*10);

	T = tm1638_read(); //
	if (T & 0x01) result |= 0x01;
	if (T & 0x10) result |= 0x10;

	T = tm1638_read(); //
	if (T & 0x01) result |= 0x02;
	if (T & 0x10) result |= 0x20;

	T = tm1638_read(); //
	if (T & 0x01) result |= 0x04;
	if (T & 0x10) result |= 0x40;

	T = tm1638_read(); //
	if (T & 0x01) result |= 0x08;
	if (T & 0x10) result |= 0x80;

	TM1638_STB (1);

	return(result);
}
/* ========================================================================== */

#endif // __USE__TM1638__

